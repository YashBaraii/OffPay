package com.example.trialpaymentapp.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.trialpaymentapp.data.Transaction
import com.example.trialpaymentapp.data.TransactionDao
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.util.UUID

class SendMoneyViewModel(private val dao: TransactionDao) : ViewModel() {

    private val _amountInput = MutableStateFlow("")
    val amountInput: StateFlow<String> = _amountInput.asStateFlow()

    private val _pinInput = MutableStateFlow("") // For local authentication by sender
    val pinInput: StateFlow<String> = _pinInput.asStateFlow()

    // This will hold the encrypted string to be converted to a QR image by the UI
    private val _encryptedQrString = MutableStateFlow<String?>(null)
    val encryptedQrString: StateFlow<String?> = _encryptedQrString.asStateFlow()

    private val _transactionFeedback = MutableStateFlow<String?>(null)
    val transactionFeedback: StateFlow<String?> = _transactionFeedback.asStateFlow()

    fun updateAmount(amount: String) {
        _amountInput.value = amount
        _encryptedQrString.value = null // Clear previous QR if amount changes
        _transactionFeedback.value = null
    }

    fun updatePin(pin: String) {
        _pinInput.value = pin
        _encryptedQrString.value = null // Clear previous QR if PIN changes
        _transactionFeedback.value = null
    }

    fun prepareTransactionAndGenerateQr() {
        val amount = _amountInput.value.toDoubleOrNull()
        val pin = _pinInput.value // PIN for local sender authentication

        if (amount == null || amount <= 0) {
            _transactionFeedback.value = "Error: Invalid amount."
            _encryptedQrString.value = null
            return
        }

        // TODO: Implement actual PIN validation logic here.
        // For example, check against a stored hash, or minimum length/complexity.
        // This is a placeholder for local authentication.
        if (pin.isBlank() || !isValidPin(pin)) { // Assuming isValidPin is a local validation method
            _transactionFeedback.value = "Error: Invalid PIN."
            _encryptedQrString.value = null
            return
        }

        val transactionId = UUID.randomUUID().toString()
        val currentTime = System.currentTimeMillis()
        // Details for the QR code - concise and relevant for the receiver
        val qrDetails = "Payment" // Or allow user to input brief details

        // Data to be embedded in the QR code (pre-encryption)
        // Format: "amount=VALUE;senderTxId=VALUE;details=VALUE;timestamp=VALUE"
        val qrDataPayload = "amount=$amount;senderTxId=$transactionId;details=$qrDetails;timestamp=$currentTime"

        // TODO: Implement robust data encryption.
        // The "encrypted security key" concept should be realized here.
        // This could involve encrypting qrDataPayload with a key known to the app,
        // or a key derived from the sender's credentials if meant for a specific receiver setup.
        val encryptedData = encryptData(qrDataPayload) // Placeholder for encryption

        val transaction = Transaction(
            id = 0, // Auto-generated by Room
            type = "SENT",
            amount = amount,
            timestamp = currentTime,
            details = "To QR: $qrDetails (ID: $transactionId)", // Local record details
            counterpartyId = transactionId, // The ID of this transaction, acting as a reference
            isSynced = false
        )

        viewModelScope.launch {
            dao.insertTransaction(transaction)
            _encryptedQrString.value = encryptedData // UI will use this to generate QR image
            _transactionFeedback.value = "Transaction ready. Show QR code to receiver."
            // Clear inputs after successful operation for security and usability
            _amountInput.value = ""
            _pinInput.value = ""
        }
    }

    // Placeholder for local PIN validation
    private fun isValidPin(pin: String): Boolean {
        // TODO: Implement actual PIN validation logic (e.g., length, complexity, or against a stored hash)
        return pin.length >= 4 // Example: minimum 4 digits
    }

    // Placeholder for actual encryption.
    // In a real app, this would involve robust cryptographic methods.
    private fun encryptData(data: String): String {
        // TODO: Replace with real encryption logic (e.g., AES).
        //       Ensure the key management is secure.
        println("Encrypting QR Data for Send: $data")
        // This current implementation is a placeholder and NOT secure.
        return "encrypted_$data" // Simulate encryption
    }

    fun clearQrData() {
        _encryptedQrString.value = null
        _transactionFeedback.value = null
    }
}
